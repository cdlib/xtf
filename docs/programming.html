<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html
PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" lang="EN">
  
<head>
  <title>XTF Programming Guide</title>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link rel="stylesheet" href="library/xtfDocStyle.css" type="text/css" />
</head>

<body bgcolor="#FFFFFF" text="#101010" >
  
<div class="BaseStyle"> 
  <p class="DocTitle" align="center">XTF Programming Guide</p>
  <p class="Heading1">Table of Contents</p>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --> 
  <ul class="NoBullets">
    <li> <b><a href="#Introduction">Introduction</a></b>     <br/>
      <br/>
    </li>
    <li> <b><a href="#textIndexer_Prog">textIndexer Programming</a></b> 
      <ul class="NoBullets">
        <li><a href="#textIndexer_DocSelector_Prog">Document Selector Programming</a></li>
        <li><a href="#textIndexer_PreFilter_Prog">Pre-Filter Programming</a></li>
      </ul>
      <br/>
    </li>
    <li> <b><a href="#crossQuery_Prog">crossQuery Programming</a></b> 
      <ul class="NoBullets">
        <li><a href="#crossQuery_QueryParser_Prog">Query Parser Programming</a></li>
        <li><a href="#crossQuery_ResultFormatter_Prog">Result Formatter Programming</a></li>
        <li><a href="#crossQuery_Common_Prog">Other Common Tasks</a></li>
      </ul>
      <br/>
    </li>
    <li> <b><a href="#dynaXML_Prog">dynaXML Programming</a></b> 
      <ul class="NoBullets">
        <li><a href="#dynaXML_DocReqParser_Prog">Document Request Parser Programming</a></li>
        <li><a href="#dynaXML_DocFormatter_Prog">Document Formatter Programming</a></li>
        <li><a href="#dynaXML_Common_Prog">Other Common Tasks</a></li>
      </ul>
      <br/>
    </li>
    <li> <b><a href="#Common_Prog">Common crossQuery/dynaXML Programming Tasks</a></b> 
      <ul class="NoBullets">
        <li><a href="#Common_ErrorGen_Prog">Error Generator Programming</a></li>
        <li><a href="#Common_Session_State">Tracking Session State</a></li>
      </ul>
      <br/>
    </li>
  </ul>
  <p class="Heading1">Introduction<a name="Introduction"></a></p>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --> 
  This guide describes how to customize the operation of the E<b>X</b>tensible 
  <b>T</b>ext <b>F</b>ramework (<b><i>XTF</i></b>) This document assumes that 
  you have completed the basic installation and configuration described in the 
  <a href="deployment.html">XTF Deployment Guide</a>, 
  and that their correct operation has been verified. <br/>
  <br/>
  The XTF system consists of Java Servlets and tools that permit users to perform 
  Web-based searching and retrieval of electronic documents. The basic organization 
  of the XTF components can be illustrated as follows: 
  <p align="center"> <a name="SummaryDiagram"></a> <img src="art/SummaryDiagram.gif" alt="Summary Diagram"/><br/>
    Figure 1: Extensible Text Framework (XTF) Overview </p>
  In this diagram, the basic flow of information is left to right. Document retrieval 
  begins with a Web-based user search query. The <i><b>crossQuery</b></i> servlet 
  checks the query against an index of available documents, and produces a list 
  of matching documents for display in a web browser. Selecting a document from 
  the search results page invokes the <i><b>dynaXML</b></i> servlet, which retrieves 
  and formats the actual document for display in a web browser. The <b><i>textIndexer</i></b> 
  tool shown at the bottom is used to update the document search index whenever 
  documents in the library are added, removed, or updated. <br/>
  <br/>
  The remainder of this document will examine how to customize the XTF tools and 
  servlets by reprogramming the XSLT templates that define their behavior. 
  <p class="Heading1">textIndexer Programming<a name="textIndexer_Prog"></a></p>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --> 
  As mentioned above in the introduction, the purpose of the <b><i>textIndexer</i></b> 
  tool is to create or update a document search index whenever documents are updated, 
  added to, or removed from the document library. If we would isolate and zoom 
  in on the <b><i>textIndexer</i></b> portion of the <a href="#SummaryDiagram">XTF 
  Overview Diagram</a> shown above, we'd see something like this: <br/>
  <p align="center"> <img src="art/textIndexerDataFlow.gif" alt="textIndexer Data Flow"/><br/>
    Figure 2: Data Flow within the <b><i>textIndexer</i></b> Tool </p>
  <p>What the diagram shows, is that the <b><i>textIndexer</i></b> uses a <b>Document 
    Selector</b> stylesheet to select which files in the document library need 
    to be indexed. For non-XML document files, the text to index is extracted 
    and converted to XML. This base XML is then processed by the <b>Document Pre-Filter</b> 
    stylesheet to add additional meta-data and/or sectioning information to the 
    text. The resulting filtered XML is then passed on to the actual <b><i>Text 
    Indexer Engine</i></b>, which breaks the text up into smaller overlapping 
    chunks and then adds them to a Lucene based word index. The index can then 
    be used by the <b><i>crossQuery</i></b> servlet to quickly locate files in 
    the document library containing any text requested by the user. Optionally, 
    the <b><i>dynaXML</i></b> servlet can also use the index to highlight in context 
    any matches in the original XML documents when they are viewed. </p>
  <p>The <b><i>textIndexer</i></b> is capable of handling many documents, of various 
    types, that are filtered in different ways. Here is a diagram showing how 
    the decisions are made.</p>
  <p align="center"> <img src="art/textIndexerDecisionTree.gif" alt="textIndexer Decision Tree"/><br/>
    Figure 3: Decision Tree of the <b><i>textIndexer</i></b> Tool </p>
  <p> The <span class="Code">textIndexer.conf</span> file, the <b>Document Selector</b> 
    stylesheet, and the <b>Pre-filter</b> stylesheet together define how the <b><i>textIndexer</i></b> 
    performs the document indexing process. A complete discussion of the <span class="Code">textIndexer.conf</span> 
    file appears in the <a href="deployment.html">XTF 
    Deployment Guide</a>, and so will not be discussed in any great depth here. 
    The inner workings of the <b>Document Selector</b> and <b>Pre-Filter</b> stylesheets 
    however, are the subject of the following subsections. </p>
  <div class="IndentL"> 
    <p class="Heading2">Document Selector Programming<a name="textIndexer_DocSelector_Prog"></a></p>
    <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --> 
    The primary purpose of the <b><i>textIndexer</i></b> <b>Document Selector</b> 
    is to select which files in the document library are to be indexed. Since 
    the <b>Document Selector</b> is an XSLT stylesheet, its input is in fact an 
    XML fragment that identifies a single directory in the document library and 
    the files that it contains. The <b>Document Selector</b> stylesheet is invoked 
    one time for each subdirectory encountered in the document library, and the 
    input it receives looks as follows: 
    <pre class="Sample"><b>&lt;directory dirPath="<span class="MacroCode">DirectoryPath</span>"&gt;

    &lt;file fileName="<span class="MacroCode">FileName1</span>"/&gt;
    &lt;file fileName="<span class="MacroCode">FileName2</span>"/&gt;
               …
    &lt;file fileName="<span class="MacroCode">FileNameN</span>"/&gt;

&lt;/directory&gt;</b></pre>
    <p> The<span class="Code"> &lt;directory...&gt; </span> tag identifies a single 
      directory in the document library, and the <b><span class="MacroCode">DirectoryPath</span></b> 
      attribute specifies its absolute file system path. Within the <span class="Code"> 
      &lt;directory...&gt; </span> tag, each of the <span class="Code">&lt;file.../&gt; 
      </span>entries identifies one of files found in the directory. Note that 
      <b><span class="MacroCode">FileName1</span></b> through <b><span class="MacroCode">FileNameN</span></b> 
      <i><b><u>do not</u></b></i> contain any path information, since the absolute 
      path that applies to all the file tags is already identified by <b><span class="MacroCode">DirectoryPath</span></b>.</p>
    <p>It is the responsibility of the <b>Document Selecto</b>r XSLT code to output 
      an XML fragment that identifies which of the files in the directory should 
      be indexed. This output XML fragment should take the following form:</p>
    <pre class="Sample"><b>&lt;indexFiles&gt;

    &lt;indexFile fileName      = "<span class="MacroCode">FileName</span>"
               <i>{</i>format       = &quot;<span class="MacroCode">FileFormatID</span>"<i>}</i>
               <i>{</i>preFilter    = &quot;<span class="MacroCode">PreFilterPath</span>"<i>}</i>
               <i>{</i>displayStyle = &quot;<span class="MacroCode">DocumentFormatterPath</span>"<i>}</i>/&gt;
                    …

&lt;/indexFiles&gt;</b></pre>
    <p>Note that the output XML consists of a single<span class="Code"> &lt;indexFiles&gt; 
      </span>container tag and one<span class="Code"> &lt;indexFile.../&gt; </span>tag 
      for each document file that needs to be indexed. Within each of the<span class="Code"> 
      &lt;indexFile.../&gt; </span>tags, the following attributes are defined:</p>
    <div class="IndentLR"> <span class="Code">fileName</span><br/>
      This attribute identifies the name of a file to be indexed, and should be 
      one of the file names received in the input XML fragment. <br/>
      <br/>
      <span class="Code">format</span><br/>
      This is an optional attribute that defines the format of the file to be 
      indexed. At this time, XML, PDF, HTML, and Plain Text indexing is supported 
      by the <i><b>textIndexer</b></i> tool, and this attribute should be set 
      to the strings<span class="Code"> XML</span>,<span class="Code"> PDF</span>, 
      <span class="Code"> HTML</span>, or<span class="Code"> Text </span>respectively, 
      depending on the native format of the file. If this attribute is not specified, 
      the <i><b>textIndexer</b></i> will try to infer the file type based on the 
      extension for the file. <br/>
      <br/>
      <span class="Code">preFilter</span><br/>
      This is an optional attribute that defines the <b>Pre-Filter </b>stylesheet 
      that the <i><b>textIndexer</b></i> should use on this document file. If 
      not specified, the text for this file will not be filtered before indexing. 
      See the <i><b>textIndexer</b></i> <a href="#textIndexer_PreFilter_Prog">Pre-Filter 
      Programming</a> section for more details about document pre-filtering.<br/>
      <br/>
      <span class="Code">displayStyle</span><br/>
      This is an optional attribute that defines the <b>Document Formatter </b>stylesheet 
      associated with the given file. If specified, the <i><b>textIndexer</b></i> 
      will create a special cache that is used by the <i> <b>dynaXML</b></i> servlet 
      to display selected documents more quickly. If not specified, the cache 
      for the current file is not created. For more details, see the discussion 
      of <a href="underHood.html#LazyFiles">Lazy Document 
      Handling</a> in the <a href="underHood.html">XTF Under 
      the Hood</a> guide.</div>
    <p>Using these XML input and output specifications shown, a simple document 
      selector might look something like this:</p>
    <pre class="Sample">&lt;xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="2.0"&gt;

  &lt;xsl:template match="directory"&gt;
    &lt;indexFiles&gt;
      &lt;xsl:apply-templates/&gt;
    &lt;/indexFiles&gt;
  &lt;/xsl:template&gt;

  &lt;xsl:template match="file"&gt;
    &lt;xsl:if test="ends-with(@fileName,'.pdf')"&gt;
	  &lt;indexFile fileName="{@fileName}" format="PDF"/&gt;
    &lt;/xsl:if&gt;
  &lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</pre>
    <p>In this simple <b>Document Selector</b> example, the first line establishes 
      the<span class="Code"> xsl </span>namespace used in the rest of the stylesheet. 
      Next, the<span class="Code"> &lt;xsl:template match=&quot;directory&quot;&gt; 
      </span>tag looks for the<span class="Code"> &lt;directory...&gt; </span>block 
      in the input XML, and writes out a corresponding<span class="Code"> &lt;indexFiles&gt; 
      </span>block to the output XML. Also the<span class="Code"> &lt;xsl:template&nbsp;match="file"&gt; 
      </span>template is applied to any tags found within the<span class="Code"> 
      &lt;directory...&gt; </span>block.</p>
    <p>The<span class="Code"> &lt;xsl:template&nbsp;match="file"&gt; </span>block 
      is the code that is actually responsible for selecting the files to be indexed. 
      In this example, only files that end in<span class="Code"> .pdf </span>are 
      passed on for indexing, and are assigned the format<span class="Code"> PDF</span>. 
      No <b>Pre-Filter</b> or <b>Document Formatter</b> stylesheets are defined, 
      and so the <i><b>textIndexer</b></i> will not pre-filter or pre-cache display 
      information for<span class="Code"> PDF </span>files.</p>
    <p>Selecting other file types for indexing is as simple as adding more<span class="Code"> 
      &lt;xsl:if...&gt; </span>clauses to the<span class="Code"> &lt;xsl:template 
      match=&quot;file&quot;&gt; </span>block, like this:</p>
    <pre class="Sample">          …
  &lt;xsl:template match="file"&gt;
    &lt;xsl:if test="ends-with(@fileName,'.pdf')"&gt;
	  &lt;indexFile fileName="{@fileName}" format="PDF"/&gt;
    &lt;/xsl:if&gt;
    <b><font color="#990000">&lt;xsl:if test="ends-with(@fileName,'.xml')"&gt;
	  &lt;indexFile fileName     = "{@fileName}"
                 preFilter    = &quot;style/textIndexer/default/prefilter.xsl&quot;
                 displayStyle = &quot;style/dynaXML/docFormatter/default/docFormatter.xsl&quot;/&gt;
    &lt;/xsl:if&gt;</font></b>
  &lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</pre>
    <p>This<span class="Code"> second &lt;xsl:if...&gt; </span>block passes XML 
      on files for indexing. Note that the<span class="Code"> &lt;indexFile...&gt; 
      </span>tag doesn't specify the file format, and so the <i><b>textIndexer</b></i> 
      is left to infer that the file type is XML from the file extension. Lastly, 
      the<span class="Code"> &lt;indexFile...&gt; </span>tag also defines a <b>Pre-Filter</b> 
      and a <b>Document Formatter</b> stylesheet for XML files.</p>
    <p>While this simple<b> Document Selector </b>example works, its file selection 
      rules are limited only to checking for certain file extensions. Clearly, 
      all the power of XSLT could be used to construct more complicated selection 
      criteria for files, including ignoring various directories, pulling in meta-data 
      from files or URLs, and so on. For a more complete example of a <b>Document 
      Selector</b> stylesheet, see the default <span class="Code"> style/textIndexer/docSelector.xsl</span> 
      stylesheet.</p>
  </div>
  <div class="IndentL"> 
    <p class="Heading2">Pre-Filter Programming<a name="textIndexer_PreFilter_Prog"></a></p>
    <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --> 
    The primary purpose of <b><i>textIndexer</i></b> <b>Pre-Filters</b> is to 
    modify the XML representation of a document prior to indexing it. The pre-filter 
    used for any particular document is defined by the <b>Document Selector</b>. 
    The main aspects of programming a pre-filter are described in the following 
    six subsections. <br/>
    <div class="IndentLR"> 
      <p class="Heading3">Defining the XTF Namespace</p>
      <br/>
      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --> 
      For the <b><i>textIndexer</i></b> pre-filter to work properly, an<span class="Code"> 
      xtf: </span>namespace must be declared at the top of the pre-filter. To 
      do this, simply add the following attribute to the<span class="Code"> &lt;xsl:stylesheet<span class="BaseStyle">...</span>&gt; 
      </span>tag at the top of the pre-filter: <br/>
      <br/>
      <div class="Sample"> <span class="Code">xmlns:xtf="http://cdlib.org/xtf"</span> 
      </div>
      <br/>
      Defining an<span class="Code"> xtf: </span>namespace in this way and then 
      prefixing <b><i>textIndexer</i></b> specific attributes with it allows the 
      <b><i>textIndexer</i></b> to distinguish its own attributes from other ones 
      in the filtered document. </div>
    <div class="IndentLR"> 
      <p class="Heading3">Preventing Text from being Indexed</p>
      <br/>
      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --> 
      There will be times when the text within certain tags in the XML representation 
      for a document should not be indexed (e.g.: versioning information about 
      the original XML file format.) The XSLT pre-filter can be prevent such tags 
      and their associated text from being indexed. There are two possible ways 
      to do this: 
      <ol>
        <li class="ListItem"> Standard XSLT programming can be used to eliminate 
          the tag and its text entirely.<br/>        <br/>
        </li>

        <li class="ListItem"> A special <span class="Code">noindex</span> attribute 
          can be added to the tag to tell the <b><i>textIndexer</i></b> to ignore 
          its contents when indexing. </li>
      </ol>
      Eliminating certain tags through the use of standard XSLT techniques has 
      the advantage that it saves space. The tag's text is not added to the search 
      index, nor is it stored by the fast retrieval database for later display 
      by the <b><i>dynaXML</i></b> servlet. By contrast, the <span class="Code">noindex</span> 
      attribute simply prevents the tag's text from being indexed. The text is 
      still stored in the fast retrieval database so that the <b><i>dynaXML</i></b> 
      servlet can display the text if necessary. <br/>
      <br/>
      A snippet of code showing the use of the <span class="Code"> noindex </span> 
      attribute can be found in the sample <span class="Code"> preFilter.xml </span> 
      file that is included with the default XTF installation. It looks as follows: 
      <br/>
      <pre class="Sample"><b>&lt;xsl:template match="teiHeader"&gt;

    &lt;xsl:copy&gt;
        &lt;xsl:copy-of select="@*"/&gt;
        <font color="#990000">&lt;xsl:attribute name="xtf:noindex" select="'true'"/&gt;</font>
        &lt;xsl:apply-templates/&gt;
    &lt;/xsl:copy&gt;

&lt;/xsl:template&gt;</b></pre>
      Notice that the <span class="Code"> noindex </span> attribute when used 
      in the pre-filter is prefixed with <span class="Code"> xtf: </span>. This 
      is the namespace used in XTF tags and attributes to prevent collisions with 
      similarly named tags and attributes defined by other programs.<br/>
      <br/>
      Finally, it should be mentioned that the <span class="Code">noindex</span> 
      attribute has two forms: <br/>
      <br/>
      <div class="IndentLR"> 
        <pre class="Code">noindex = true/yes, false/no</pre>
      </div>
      and <br/>
      <br/>
      <div class="IndentLR"> 
        <pre class="Code">index   = false/no, true/yes</pre>
      </div>
      Both forms enable or disable indexing, but their logic is inverted so that 
      the XSLT programmer can choose the wording that makes the most sense in 
      any given situation. 
      <p class="Heading3">Controlling Proximity</p>
      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --> 
      If an XTF user specifies a list of words to search for, the <b><i>crossQuery</i></b> 
      servlet will rank any matching words that are closer together as better 
      matches than ones that are far apart. This is what is known as <b><i>proximity 
      searching</i></b>. <br/>
      <br/>
      There are times however when simple proximity matches will produce undesired 
      results. For example, consider the case where a query matches some words 
      in two different places in a document. For the first match, the words are 
      very close together but in two different chapters' tags. For the second 
      match, the words are all in the same chapter, but slightly further apart. 
      In this case, the proximity search mechanism will incorrectly give a higher 
      score to match with the words that are closer together but split across 
      two chapters. <br/>
      <br/>
      To correct for these kinds of situations, the pre-filter can insert a <b><i>proximity 
      break attribute</i></b> into a tag. Doing so effectively puts an infinite 
      distance between the tag with the break and the text before it, thus entirely 
      preventing proximity matches from being found that span the two tags. For 
      example, to solve the "proximity across chapters" problem described above, 
      a pre-filter might include some code like this: <br/>
      <br/>
      <pre class="Sample"><b>&lt;xsl:template <font color="#990000">match="chapter"</font>&gt;

    &lt;xsl:copy&gt;
        &lt;xsl:copy-of select="@*"/&gt;
        <font color="#990000">&lt;xsl:attribute name="xtf:proximitybreak" select="'true'"/&gt;</font>
        &lt;xsl:apply-templates/&gt;
    &lt;/xsl:copy&gt;

&lt;/xsl:template&gt;</b></pre>
      In this example, the important code is on first and fourth lines. The first 
      line tells the pre-filter to look for "chapter" tags. And when it finds 
      one, the fourth line adds a proximity break attribute. Adding this code 
      to the pre-filter would ensure that proximity matches are never found that 
      span two "chapter" tags. <br/>
      <br/>
      Sometimes it may still be desirable to find proximity matches across sections, 
      but de-emphasize them compared to matches found entirely within a section. 
      In this case, the<span class="Code"> sectionBump </span>attribute can be 
      used in place of a proximity break. Unlike the<span class="Code"> proximityBreak 
      </span>tag, the<span class="Code"> sectionBump </span> tag can be told how 
      much distance (as a number of words) to introduce between two adjacent sections. 
      For example, this code: <br/>
      <br/>
      <pre class="Sample"><b>&lt;xsl:template <font color="#990000">match="chapter"</font>&gt;

    &lt;xsl:copy&gt;
        &lt;xsl:copy-of select="@*"/&gt;
        <font color="#990000">&lt;xsl:attribute name="xtf:sectionBump" select="10"/&gt;</font>
        &lt;xsl:apply-templates/&gt;
    &lt;/xsl:copy&gt;

&lt;/xsl:template&gt;</b></pre>
      would separate adjacent chapters from each other by ten words. Proximity 
      matches across chapters would still be found, but they would be considered 
      10 words further apart (and therefore less relevant) than similar matches 
      found entirely within a single section. <br/>
      <br/>
      Just as it may be desirable to de-emphasize proximity matches across adjacent 
      sections, it may also be desirable to control proximity matches across sentence 
      boundaries. To accomplish this, the sentenceBump attribute can be added 
      to a tag like this: <br/>
      <br/>
      <pre class="Sample"><b>&lt;xsl:template <font color="#990000">match="DocText"</font>&gt;

    &lt;xsl:copy&gt;
        &lt;xsl:copy-of select="@*"/&gt;
        <font color="#990000">&lt;xsl:attribute name="xtf:sentenceBump" select="5"/&gt;</font>
        &lt;xsl:apply-templates/&gt;
    &lt;/xsl:copy&gt;

&lt;/xsl:template&gt;</b></pre>
      In this example, a hypothetical tag under which all other document tags 
      and text exist has its sentenceBump value set to 5 words. This effectively 
      separates the end of one sentence from the beginning of the next by five 
      words. Doing so makes proximity matches across sentences less relevant than 
      a similar proximity match entirely within a single sentence. 
      <p class="Heading3">Sectioning Documents</p>
      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --> 
      Another attribute that can be added to document tags is the<span class="Code"> 
      sectionType </span>attribute. This attribute allows you to assign names 
      to tags within a document. Doing so would allow permit advanced user queries 
      that only search for text in specific section types. Consider the following 
      example: <br/>
      <br/>
      <pre class="Sample"><b>&lt;xsl:template <font color="#990000">match="ChapterTitle"</font>&gt;

    &lt;xsl:copy&gt;
        &lt;xsl:copy-of select="@*"/&gt;
        <font color="#990000">&lt;xsl:attribute name="xtf:sectionType" select="'ChapterTitle'"/&gt;</font>
        &lt;xsl:apply-templates/&gt;
    &lt;/xsl:copy&gt;

&lt;/xsl:template&gt;</b></pre>
      This XSLT code simply labels the text indexed for a chapter title with a 
      "ChapterTitle" section type. With the text labeled in this manner, the query 
      page presented to the user could provide an advanced search option to look 
      for text only in chapter titles. We'll talk more about how to actually do 
      this in the section below on <a href="#crossQuery_QueryParser_Prog">programming 
      the <b><i>crossQuery</i></b> servlet's Query Parser Stylesheet</a>. <br/>
      <br/>
      One other thing to mention about <span class="Code">sectionType</span> attributes 
      is that they may be used in nested tags. The <b><i>textIndexer</i></b> maintains 
      an internal stack of nested section types, and correctly restores previous 
      section types when a given section/tag ends. 
      <p class="Heading3">Relevance Boost</p>
      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --> 
      There may be times when it is useful to boost or de-emphasize the relevance 
      of text in a particular part of a document. Consider the case where you 
      had a document that was a book of quotations. In such a document, it might 
      make sense to boost the relevance of the text in the actual quotations as 
      compared to any text that discussions the quotations. To facilitate this, 
      the <b><i>textIndexer</i></b> pre-filter provides a <b><i>wordBoost</i></b> 
      attribute. The following example illustrates its use: <br/>
      <br/>
      <pre class="Sample"><b>&lt;xsl:template <font color="#990000">match="Quotation"</font>&gt;

    &lt;xsl:copy&gt;
        &lt;xsl:copy-of select="@*"/&gt;
        <font color="#990000">&lt;xsl:attribute name="xtf:wordboost" select="1.5"/&gt;</font>
        &lt;xsl:apply-templates/&gt;
    &lt;/xsl:copy&gt;

&lt;/xsl:template&gt;</b></pre>
      This XSLT code simply boosts text found in <span class="Code">Quotation</span> 
      tags to be 1.5 times more relevant than non-boosted text in the document. 
      Conversely, to de-emphasize text simply use a value between zero and one 
      (e.g., a boost of 0.5 would make text half as relevant when searching.) 
      <br/>
      <br/>
      As with <span class="Code">section</span> attributes, the wordboost attribute 
      may be used in nested tags. The <b><i>textIndexer</i></b> maintains an internal 
      stack of nested boost values, and correctly restores previous values when 
      a given section/tag ends. Note however that boost values in nested tags 
      <b><i>do not</i></b> accumulate. That is, a tag with a boost value of 1.5 
      will boost the relevance of its words by 1.5, regardless of the boost values 
      applied to any tags that contain it. 
      <p class="Heading3">Adding or Marking Meta-Data</p>
      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --> 
      There are times when it is useful to record Meta-Data for a document. Meta-Data 
      is simply information about a document that is not part of the document 
      text itself. The author name, document publication date, and document revision 
      are all examples of Meta-Data. The <b><i>textIndexer</i></b> system supports 
      the concept of Meta-Data through the use of the <span class="Code">meta</span> 
      attribute. Using the pre-filter to add this attribute to a tag causes name 
      of the tag and its contents to be recorded in a special Meta-Data section 
      of the index for the document. For example: <br/>
      <br/>
      <pre class="Sample"><b>&lt;xsl:template <font color="#990000">match="PublicationInfo"</font>&gt;

    &lt;xsl:copy&gt;
        &lt;xsl:copy-of select="@*"/&gt;
        <font color="#990000">&lt;xsl:attribute name="xtf:meta" select="'true'"/&gt;</font>
        &lt;xsl:apply-templates/&gt;
    &lt;/xsl:copy&gt;

&lt;/xsl:template&gt;</b></pre>
      <p>This snippet of pre-filter code would take any tag with the name <span class="Code">PublicationInfo</span> 
        and add a <span class="Code">meta</span> attribute to it, thus telling 
        the <b><i>textIndexer</i></b> to add the publication info to the meta-data 
        index for the current document rather than the main text index. Once meta-data 
        has been recorded for a document, it can be searched by modifying the 
        <b><i>crossQuery</i></b> servlet's Query Parser Stylesheet to generate 
        meta search requests. Doing so is described in detail below in the <a href="#crossQuery_QueryParser_Prog">Query 
        Parser Programming</a> section below.</p>
      <p>Another way in which meta-data for a document can be used is as a query 
        <i><b> sort key</b></i>. Sort keys are used by the <i><b>crossQuery</b></i> 
        servlet to reorder how query matches are displayed for the user. To use 
        a meta-field as a sort key, its contents must not be tokenized. Since 
        tokenizing is turned on by default to make a meta-data field searchable, 
        the pre-filter code that processes meta-data must explicitly turn tokenizing 
        off. This is accomplished as follows:</p>
      <pre class="Sample"><b>&lt;xsl:template match="PublicationInfo"&gt;

    &lt;xsl:copy&gt;
        &lt;xsl:copy-of select="@*"/&gt;
        &lt;xsl:attribute name="xtf:meta" select="'true'"/&gt;
        <font color="#990000">&lt;xsl:attribute name="xtf:tokenize" select="'no'"/&gt;</font>
        &lt;xsl:apply-templates/&gt;
    &lt;/xsl:copy&gt;

&lt;/xsl:template&gt;</b></pre>
      <p>Like the previous example, this pre-filter code would take any tag with 
        the name <span class="Code">PublicationInfo</span> and mark it as meta-data. 
        But the addition of the line of code shown in red disables tokenizing 
        so that the meta-data can be used as a sort key by the <i> <b>crossQuery</b></i> 
        servlet.</p>
      <p>It is important to note that since meta-data must be tokenized to be 
        searchable, and it must not be tokenized to be used as a sort key, meta-based 
        searching and sorting operations are effectively mutually exclusive. If 
        you want to perform both searching and sorting on a collection of meta-data, 
        you'll need to add code to your prefilter to produce two copies of that 
        meta-data: one copy for searching that is tokenized, and one copy for 
        sorting that is not tokenized.</p>
      <p class="Heading3">Pre-Filters and Lazy-Tree Building</p>
      <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --> 
      <p>The XTF system makes use of <i><b>Lazy Tree</b></i> files to help speed 
        document retrieval and to help the <i><b>dynaXML</b></i> servlet highlight 
        search results in context. By default, lazy tree files are generated at 
        index time by the <i><b>textIndexer</b></i>. However, through the use 
        of the<span class="Code"> -nobuildlazy </span> command-line argument, 
        the <i><b>textIndexer</b></i> can be instructed to not build the lazy 
        tree files. In this case, the <i><b>dynaXML</b></i> servlet will build 
        the lazy trees files when it needs them.<br/>
      </p>
      <p>If the<span class="Code"> -nobuildlazy </span> command-line is used to 
        delay the building of lazy tree information until document retrieval, 
        it is imperative that the prefilter specified by the<span class="Code"> 
        docSelector.xsl </span>stylesheet is the same one specified by the <i><b>dynaXML</b></i>'s<span class="Code"> 
        docReqParser.xsl </span>stylesheet. If the two stylesheets use different 
        prefilters, the search result information generated by the <i><b>crossQuery</b></i> 
        servlet will not match the highlighting information in the lazy tree files 
        generated by the dynaXML servlet, and chaos will ensue. </p>
    </div>
    <p class="Heading2">Summary<a name="textIndexer_PreFilter_Prog"></a></p>
    <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --> 
    <p>In closing, a few additional facts should be mentioned about the attributes 
      supported by the XTF system:</p>
    <ol>
      <li class="ListItem"> All the examples above show the <b><i>textIndexer</i></b> 
        pre-filter adding attributes to the XML representation for a document. 
        However, for native XML documents, the attributes could have simply been 
        embedded in the original source document tags. The disadvantage of doing 
        so, however, is that the attributes in every XML document would need to 
        be updated whenever indexing changes are made to the XTF system.<br/>
        <br/>
      </li>
      <li class="ListItem"> A single tag can be assigned more than one attribute. 
        For example, a tag could be assigned both a word boost and a section title 
        if desired. Note however that some combinations (like <span class="Code">sectionType</span> 
        + <span class="Code">proximitybreak</span>) are redundant and unnecessary.<br/>
        <br/>
      </li>
      <li class="ListItem"> Currently, when a <span class="Code">meta</span> attribute 
        is added to a tag, all the other XTF specific attributes are ignored (e.g., 
        <span class="Code">wordboost</span>, <span class="Code">proximitybreak</span>, 
        etc.) </li>
    </ol>
    Finally, it should be noted that the sample <span class="Code">style/textIndexer/common/preFilterCommon.xsl</span> 
    beneath the base XTF directory (i.e., <span class="Code">XTF_HOME</span>) 
    is a good starting point for creating your own customized pre-filters. </div>
  <br/>
  <!-- textIndexer --> 
  <hr/>
  <p class="Heading1">crossQuery Programming<a name="crossQuery_Prog"></a></p>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --> 
  The <b><i>crossQuery</i></b> servlet previously shown in the XTF overview allows 
  users to search the document library for particular words or phrases. If we 
  look more closely at the <b><i>crossQuery</i></b> portion of the <a href="#SummaryDiagram">XTF 
  Overview Diagram</a>, we'll see something like this: <br/>
  <p align="center"> <img src="art/crossQueryDataFlow.gif" alt="crossQuery Data Flow"/><br/>
    Figure 4: Data Flow in the <b><i>crossQuery</i></b> Servlet </p>
  Once again, the basic flow of information in this diagram is left to right. 
  A document search begins with a the user specifying some text to search for 
  on a web page. The query is assembled into a URL of the form: <br/>
  <br/>
  <div class="Sample"> <span class="Code"> http://<span class="MacroCode">yourserver</span>:8080/xtf/search?text=<span class="MacroCode">TextToFind</span> 
    </span> </div>
  <p><br/>
    This query URL is then passed on to the <i><b>crossQuery</b></i> servlet for 
    processing. The first thing the servlet does is translate the query URL into 
    an XML query that the <b><i>crossQuery</i></b> search engine can actually 
    understand. This translation is accomplished by the XSLT based <b>Query Parser</b> 
    (<span class="Code">queryParser.xsl</span>.) <br/>
    <br/>
    The <b><i>crossQuery</i></b> search engine then uses the XML query to look 
    for occurrences of the specified text in the document index. Any matches that 
    are found in the index are assembled into a list of XML tags, and passed on 
    to <b>Result Formatter</b> stylesheet (<span class="Code">resultFormatter.xsl</span>.) 
    The <b>Result Formatter</b> stylesheet then converts the list of matches into 
    HTML for review by the user.</p>
  <p>Thus, <i><b>XTF</b></i> allows you to configure, through stylesheets, exactly 
    how queries will be interpreted and how the results will be formatted. For 
    advanced users, there is one more level of configurability: you can actually 
    implement several independent query interfaces, each with their own <b>Query 
    Parser</b>. How does the <i><b>crossQuery</b></i> servlet decide which parser 
    to run? By calling another stylesheet you can optionally configure, the <b>Query 
    Router</b>. <span class="Red">Note that routing is an advanced feature, and 
    most first-time XTF implementors should stick with the default router and 
    focus on the <b>Query Parser</b>.</span> </p>
  <p>Here's a diagram showing the path of decision making in <i><b>crossQuery</b></i>.<br/>
  </p>
  <p align="center"> <img src="art/crossQueryDecisionTree.gif" alt="crossQuery Decision Tree"/><br/>
    Figure 5: Decision Tree of the <b><i>crossQuery</i></b> Servlet </p>
  <p>A great way to get a hands-on feel for how <i><b>crossQuery</b></i> works 
    is to use the built-in &quot;Debug Step&quot; mode. Simply add <span class="Code">&amp;debugStep=1</span> 
    to any search URL. The generated web page will let you step through the entire 
    process, with detailed explanations and real data. The first step looks like 
    this:</p>
  <p align="center"> <img src="Art/SearchDebugStep.gif" alt="Search Debug Step"/><br/>
    Figure 6: Using <b><i>crossQuery</i></b>'s Debug Step Mode</p>
  <p>The remaining two subsections describe in detail how to write <b>Query Parser</b> 
    and <b>Result Formatter</b> XSLT code to carry out the necessary translations. 
  </p>
  <div class="IndentL"> 
    <p class="Heading2">Query Parser Programming<a name="crossQuery_QueryParser_Prog"></a></p>
    <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --> 
    As previously noted, the <b>Query Parser</b> is responsible for translating 
    a URL based query into an XML query that the search engine can actually understand. 
    Consider the following pseudo-query: <br/>
    <br/>
    <div class="IndentLR"> <span class="Code">Find all occurrences of "man" and 
      "war" but not "Man of War".</span> </div>
    <br/>
    What we're trying to find here is any document containing both "man" and "war", 
    but not "Man of War", which is a kind of jellyfish. In theory, the web page 
    into which the user types the search query could take a simplified English-like 
    representation of the query with the form: <br/>
    <br/>
    <div class="IndentLR"> <span class="Code">find man and war but not "Man of 
      War"</span> </div>
    <br/>
    but writing an XSLT parser to process it would be a complicated endeavor. 
    To simplify things, we'll assume that the web page has a field that accepts 
    all the words or phrases to find, and another field that accepts all the words 
    or phrases to exclude. For our specific example, the user would type <br/>
    <br/>
    <div class="IndentLR"> <span class="Code"> man war </span> </div>
    <br/>
    into the <b>text to find</b> field, and <br/>
    <br/>
    <div class="IndentLR"> <span class="Code"> "Man of War" </span> </div>
    <br/>
    into the <b>text to exclude</b> field. Note that each word or phrase is separated 
    from the others by a space, and that an exact phrase (like <span class="Code">Man 
    of War</span>) is enclosed in double-quotes to differentiate it from a list 
    of individual words. The resulting query URL that would be passed to the <b><i>crossQuery</i></b> 
    servlet would then look something like this: <br/>
    <br/>
    <div class="Sample"> <span class="Code"> http://<span class="MacroCode">yourserver</span>:8080/xtf/search?text=man+war&amp;text-exclude=%22Man+of+War%22 
      </span> </div>
    <br/>
    Notice that the first part of the URL (everything before the <b>?</b> symbol) 
    invokes the <b><i>crossQuery</i></b> servlet, and second part of the URL (everything 
    after the <b>?</b> symbol) defines the search to be performed. Also notice 
    that search to be performed is represented by two parameters: <br/>
    <br/>
    <table width="90%" cellpadding="0" cellspacing="12">
      <tr> 
        <td width="213" align="right" valign="baseline" class="Code">text=man+war</td>
        <td width="246" valign="baseline"><span class="BaseStyle">The list of 
          words search for.</span></td>
      </tr>
      <tr> 
        <td width="213" align="right" valign="baseline" class="Code">text-exclude=%22Man+of+War%22</td>
        <td width="246" valign="baseline"><span class="BaseStyle">The phrase to 
          exclude from the search.</span></td>
      </tr>
    </table>
    <br/>
    These two parameters carry the "find" and "exclude" semantics represented 
    by the two fields of our imagined query Web-Page. As is typical for URLs, 
    the spaces in each parameter have been replaced with plus signs (<span class="Code">+</span>), 
    and the double-quote characters have been replaced with their ANSI equivalent 
    hexadecimal values. <br/>
    <br/>
    Since the <b>Query Parser</b> is written in XSLT, it actually expects an XML 
    document as its input, and not a URL like the one presented above. Consequently, 
    the <b><i>crossQuery</i></b> servlet preprocesses the query URL and turns 
    it into an XML input fragment for the <b>Query Parser</b> to translate. In 
    general, the input XML passed to the <b>Query Parser</b> looks like this: 
    <pre class="Sample"><b>&lt;parameters&gt;

  &lt;param name="<span class="MacroCode">ParamName</span>" value="<span class="MacroCode">ParamValue</span>"&gt;
      <span class="MacroCode">Token</span> | <span class="MacroCode">Phrase</span>
      <span class="MacroCode">Token</span> | <span class="MacroCode">Phrase</span>
           …
  &lt;/param&gt;
      …
&lt;/parameters&gt;</b></pre>
    where <span class="MacroCode">Token</span> specifies a single word, and has 
    the form: <br/>
    <br/>
    <div class="Sample"> <span class="Code"> &lt;token value="<span class="MacroCode">Word</span>" 
      isWord = "<span class="MacroCode">YesOrNo</span>"/&gt; </span> <br/>
      <br/>
      where <br/>
      <br/>
      <table cellpadding="0" cellspacing="12">
        <tr> 
          <td width="16%" align="right" valign="top" class="Code"> value="<span class="MacroCode">Word</span>" 
          </td>
          <td><span class="BaseStyle">is the actual word or symbol extracted from 
            the URL.</span></td>
        </tr>
        <tr> 
          <td width="16%" align="right" valign="top" class="Code"> isWord="<span class="MacroCode">YesOrNo</span>" 
          </td>
          <td><span class="BaseStyle">identifies whether the token is a word or 
            punctuation symbol.</span></td>
        </tr>
      </table>
    </div>
    <br/>
    and <span class="MacroCode">Phrase</span> specifies an entire phrase extracted 
    as a single string, with the form: <br/>
    <br/>
    <div class="Sample"> 
      <pre class="Code">&lt;phrase value="<span class="MacroCode">StringOfWords</span>"&gt;
    <span class="MacroCode">Token</span>
       …
    <span class="MacroCode">Token</span>
&lt;/phrase&gt;
</pre>
      where <br/>
      <br/>
      <table cellpadding="0" cellspacing="12">
        <tr> 
          <td width="16%" align="right" valign="top" class="Code"> value="<span class="MacroCode">StringOfWords</span>" 
          </td>
          <td><span class="BaseStyle">is the entire phrase extracted from the 
            URL as a single string.</span></td>
        </tr>
        <tr> 
          <td width="16%" align="right" valign="top" class="Code"> <span class="MacroCode">Token</span>...<span class="MacroCode">Token</span> 
          </td>
          <td> <span class="BaseStyle"> is the original phrase broken down into 
            individual token tags for each word or symbol in the phrase. </span> 
          </td>
        </tr>
      </table>
    </div>
    <br/>
    For our particular example URL, the input XML fragment passed to the <b>Query 
    Parser</b> would be: <br/>
    <br/>
    <pre class="Sample"><b>&lt;parameters&gt;

  &lt;param name="text" value="man war"&gt;
     &lt;token value="man" isWord="yes"/&gt;
     &lt;token value="war" isWord="yes"/&gt;
  &lt;/param&gt;

  &lt;param name="text-exclude" value="&#34;Man of War&#34;"&gt;
     &lt;phrase value="Man of War"/&gt;
         &lt;token value="Man" isWord="yes"/&gt;
         &lt;token value="of"  isWord="yes"/&gt;
         &lt;token value="War" isWord="yes"/&gt;
     &lt;/phrase&gt;
  &lt;/param&gt;

&lt;/parameters&gt;</b></pre>
    As mentioned before, it is the job of the the <b>Query Parser</b> XSLT code 
    to translate the above input into an XML query that the <b><i>crossQuery</i></b> 
    search engine understands. The general format of an XML query passed to the 
    search engine has the form: <br/>
    <br/>
    <pre class="Sample"><b>&lt;query indexPath="<span class="MacroCode">LocationOfIndexDBToUse</span>" style="<span class="MacroCode">ResultFormatterLocation</span>"&gt;

    <span class="MacroCode">QueryElements</span>

&lt;/query&gt;</b></pre>
    <p>The <span class="Code">&lt;query...&gt;</span> tag is always the outermost 
      tag in a query, containing all the other tags that define the query to be 
      performed. Through its <span class="Code">indexPath="<span class="MacroCode">LocationOfIndexDBToUse</span>&quot;</span> 
      attribute, this tag identifies the Lucene index to use when performing the 
      query. Through its <span class="Code">style="<span class="MacroCode">ResultFormatterLocation</span>"</span> 
      attribute, it also defines the path to the <a href="#crossQuery_ResultFormatter_Prog">Result 
      Formatter</a> XSLT stylesheet that will format the query results. For both 
      attributes, the path specified is relative to the base install path for 
      the XTF system (i.e.,<span class="Code"> XTF_HOME</span>.) <br/>
      <br/>
      Within the <span class="Code">&lt;query...&gt;</span> tag, the <span class="MacroCode">QueryElements</span> 
      identify the type of query to perform. The simplest query that can be performed 
      is a query for a single word, or <i><b>term</b></i>. It has the form:</p>
    <pre class="Sample"><b>&lt;term field=&quot;<span class="MacroCode">FieldToSearch</span>&quot;&gt;

    <span class="MacroCode">WordToFind</span>

&lt;/term&gt;</b></pre>
    <p>This tag indicates that we wish to find a single word in the field identified 
      by <span class="Code">field=</span>&quot;<span class="MacroCode">FieldToSearch</span>&quot; 
      . If we wish to search the main text of a document, <span class="MacroCode">FieldToSearch</span> 
      should be set to <span class="Code"><span class="Code">text</span></span>. 
      If we wish to search meta data for a document, we would use a meta-data 
      field name instead, like <span class="Code">creator</span> or <span class="Code">subject</span>. 
      Once the search field been identified, the single word we actually wish 
      to find should substituted for <span class="MacroCode">WordToFind</span>.<br/>
      <br/>
      The next simplest query to perform is a <i><b>phrase query</b></i>. It has 
      the form:</p>
    <pre class="Sample"><b>&lt;phrase field=&quot;<span class="MacroCode">FieldToSearch</span>&quot;&gt;
    <span class="MacroCode">Term</span>
    <span class="MacroCode">Term</span>
      …
&lt;/phrase&gt;</b></pre>
    <p>This query contains one or more term tags that together identify a phrase 
      to find, rather than a single word. For example, the <b>&quot;Man of War&quot;</b> 
      phrase in our sample query above would be constructed using the <span class="Code">&lt;phrase...&gt;</span> 
      and <span class="Code">&lt;term...&gt;</span> tags as follows:</p>
    <pre class="Sample"><b>&lt;phrase field=&quot;text&quot;&gt;
    &lt;term&gt; Man &lt;/term&gt;
    &lt;term&gt; of  &lt;/term&gt;
    &lt;term&gt; War &lt;/term&gt;
&lt;/phrase&gt;</b></pre>
    <p>It should be noted from this example the <span class="Code">field=&quot;<span class="MacroCode">FieldToSearch</span>&quot;</span> 
      attribute doesn't need to be specified in each of the <span class="Code">&lt;term...&gt;</span> 
      tags, since the enclosing <span class="Code">&lt;phrase...&gt;</span> tag 
      has already identified the field to be searched.</p>
    <p>The one remaining query element that we would need to construct a complete 
      query for our man and war not &quot;Man of War&quot; example is the <i><b>query 
      clause</b></i>. It has the form: </p>
    <pre class="Sample"><b>&lt;<span class="MacroCode">ClauseType</span> field=&quot;<span class="MacroCode">FieldToSearch</span>&quot;&gt;
    <span class="MacroCode">Term</span> | <span class="MacroCode">Clause</span>
    <span class="MacroCode">Term</span> | <span class="MacroCode">Clause</span>
         …
&lt;/<span class="MacroCode">ClauseType</span>&gt;</b></pre>
    Where valid <span class="MacroCode">ClauseType</span> values are <span class="Code">and</span>, 
    <span class="Code">or</span>, <span class="Code">not</span>, <span class="Code">near</span>, 
    <span class="Code">phrase</span>, and <span class="Code">exact</span>. Each 
    of these clause types do pretty much what you would expect: 
    <ul>
      <li class="ListItem"> The <span class="Code">and</span> clause requires 
        all its sub-terms/phrases/clauses to be present for a match to occur. 
      </li>
      <li class="ListItem"> The <span class="Code">or</span> clause requires any 
        one of its sub-terms/phrases/clauses to be present for a match to occur. 
      </li>
      <li class="ListItem"> The <span class="Code">not</span> clause requires 
        that none of its sub-terms/phrases/clauses are present for a match to 
        occur. </li>
      <li class="ListItem"> The <span class="Code">near</span> clause requires 
        all its sub-terms/phrases/clauses to be <b><i>near</i></b> each other 
        for a match to occur. The definition of <b><i>near</i></b> is fairly complicated, 
        and will not be discussed here. See the <a href="tagRef.html#crossQuery_QueryParser_Tags">Query 
        Parser tag reference</a> for an in-depth description of the <span class="Code">near</span> 
        clause. </li>
      <li class="ListItem">The <span class="Code">exact</span> clause operates 
        just like the<span class="Code"> phrase </span>clause, except that it 
        matches the entire contents of a field only, whereas a<span class="Code"> 
        phrase </span>clause can match anywhere within the field. </li>
    </ul>
    Now, for the sample query we discussed above: <br/>
    <br/>
    <div class="IndentLR"> <span class="Code">man and war not "Man of War"</span> 
    </div>
    <br/>
    the complete query would look as follows: 
    <pre class="Sample"><b>&lt;query indexPath=&quot;./index&quot; style="./style/crossQuery/resultFormatter.xsl"&gt;
    &lt;and field=&quot;text&quot;&gt;
        &lt;term&gt; man &lt;/term&gt;
        &lt;term&gt; war &lt;/term&gt;
        &lt;not&gt;
            &lt;phrase&gt;
                &lt;term&gt; Man &lt;/term&gt;
                &lt;term&gt; of  &lt;/term&gt;
                &lt;term&gt; War &lt;/term&gt;
            &lt;/phrase&gt;
        &lt;/not&gt;
    &lt;/and&gt;
&lt;/query&gt;</b></pre>
    At this point, the trick is to write a <span class="Code">queryParser.xsl</span> 
    stylesheet that converts the given input XML fragment into the output XML 
    query shown above. Unfortunately, writing XSLT is well beyond the scope of 
    this document and will not be discussed here. The good news however is that 
    the sample <span class="Code">queryParser.xsl</span> included with the XTF 
    installation performs the necessary query conversion illustrated in this example, 
    and is a good starting point for creating your own custom Query Parser. <br/>
    <br/>
    It should also be noted that the various query tags illustrated here have 
    been shown in their simplest form for the sake of clarity. For example the 
    <span class="MacroCode">Query</span> tag has additional attributes that allow 
    query matches to be returned a few at a time. This allows the Result Formatter 
    to display a short page of search results rather than a single page containing 
    every result in the repository. Another thing to note is that <span class="MacroCode">Phrase</span> 
    tags are in fact recursive, and can contain sub-phrases or clauses (not just 
    <span class="MacroCode">Term</span> tags.) For a complete description of query 
    tags and the attributes they support, please refer to the <a href="tagRef.html#crossQuery_QueryParser_Tags">Query 
    Parser Tag Reference</a>. 
    <p class="Heading2">Result Formatter Programming<a name="crossQuery_ResultFormatter_Prog"></a></p>
    <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --> 
    <p>The last stage in the <i><b>crossQuery</b></i> data flow is formatting 
      the results. Recall that the URL parameters were parsed into an XTF-compatible 
      query by the <b>Query Parser</b> stylesheet. Then the <b>Text Engine</b> 
      runs that query against indexed data, resulting in a list of matching documents. 
      The final task is to put a pretty face on things, and that's where the <b>Result 
      Formatter</b> stylesheet enters in. It transforms the XML list of documents 
      into an easy-to-use HTML result page.</p>
    <p>How does XTF know which stylesheet to use? Simple: the <b>Query Parser</b> 
      tells it. The<span class="Code"> &lt;query...&gt; </span>tag it outputs 
      specifies a<span class="Code"> style </span>attribute, which points at the 
      <b>Result Formatter</b> stylesheet that you want XTF to run. Thus, it is 
      quite possible -- and often useful -- to have multiple result formatters 
      for different purposes or display modes, and program the <b>Query Parser</b> 
      to decide which formatter to run based on a URL parameter. But we'll assume 
      for now that you only have one formatter.</p>
    <p>To accomplish its work, the <b>Result Formatter</b> receives three pieces 
      of data:</p>
    <ol>
      <li> 
        First, it receives the same<span class="Code"> 
            &lt;parameters...&gt; </span>block that was passed to the <b>Query 
            Parser</b>. This contains parsed versions of all the URL parameters, 
            in case the <b>Result Formatter</b> wants to act on these as well.
      </li>
      <li>Next, it also receives a copy of the full<span class="Code"> &lt;query&gt; 
        </span>element that was produced by the <b>Query Parser</b>.</li>
      <li>Finally and most importantly comes a list of documents that matched 
        the query. Each<span class="Code"> &lt;docHit...&gt; </span>element will 
        contain meta-data in addition to snippets of matching text from the main 
        body of each document.</li>
    </ol>
    <p>It's easy to view the XML that <b><i>crossQuery</i></b> sends to the <b>Result 
      Formatter</b>. Simply append<span class="Code"> &amp;raw=1 </span>to the 
      URL, and the servlet will bypass the formatter completely and display the 
      raw XML directly in your browser. A great way to plan your stylesheet is 
      to run some sample queries and look at the raw XML, then try to envision 
      how you want it to look in HTML.</p>
    <p>Here's a real-life sample of <b>Result Formatter</b> input, coming from 
      a query for the words &quot;man&quot; and &quot;war&quot;. Much of the repetitive 
      information has been snipped out so you can get a quick idea of the structure 
      without getting bogged down in details.</p>
    <pre class="Sample">&lt;<b>crossQueryResult</b> queryTime=&quot;0.32&quot; totalDocs="8" startDoc="1" endDoc="8">

  &lt;<b>parameters</b>>
    &lt;param name="text" value="man war">
       &lt;token value="man" isWord="yes"/>
       &lt;token value="war" isWord="yes"/>
    &lt;/param>
    <span class="MacroCode">...additional URL parameters here...</span>
  &lt;/<b>parameters</b>>

  &lt;<b>query</b> indexPath="index" termLimit="1000" workLimit="1000000"
         style="style/crossQuery/resultFormatter/default/resultFormatter.xsl"
         startDoc="1" maxDocs="10">
     &lt;and field="text" maxSnippets="3" maxContext="100">
       &lt;term>man&lt;/term>
       &lt;term>war&lt;/term>
     &lt;/and>
  &lt;/<b>query</b>>
  
  &lt;<b>docHit</b> rank="1" path="default:r1/ft2s2004r1/ft2s2004r1.xml" score="100" totalHits="3">
    &lt;meta>
       &lt;title>Asylia: Territorial Inviolability in the Hellenistic World&lt;/title>
       &lt;creator>Kent J. Rigsby&lt;/creator>
       <span class="MacroCode">...more meta-data here...</span>
    &lt;/meta>
    &lt;snippet rank="1" score="100">inspoliatus : [Sall. ] Resp . 1.2.7, in the civil &lt;hit>
          &lt;term>war&lt;/term> 
          &lt;term>men&lt;/term>
       &lt;/hit> fled to Pompey "as debtors use a sacred&lt;/snippet>
    &lt;snippet rank="2" score="53">he explains, will win the favor of gods and &lt;hit>
          &lt;term>men&lt;/term>, and just &lt;term>wars&lt;/term>
       &lt;/hit> are defensive. The locus classicus is&lt;/snippet>
    &lt;snippet rank="3" score="53">the Roman peace, which ended the state of &lt;hit>
          &lt;term>war&lt;/term> among &lt;term>men&lt;/term>
       &lt;/hit>). More generally, legend told of various&lt;/snippet>
  &lt;/<b>docHit</b>>

  &lt;<b>docHit</b> rank="2" path="default:7d/ft7w10087d/ft7w10087d.xml" score="76" totalHits="6">
    &lt;meta>  <span class="MacroCode">...meta-data here...</span> &lt;/meta>
    &lt;snippet rank="1" score="100">the mother of shields." Kunu refers to the &lt;hit>
          &lt;term>war&lt;/term> shields &lt;term>men&lt;/term>
       &lt;/hit> used to fashion from lighter bark, some&lt;/snippet>
    <span class="MacroCode">...more snippets here...</span>
  &lt;/<b>docHit</b>>

  &lt;<b>docHit</b> rank="3" path="default:pf/ft7r29p1pf/ft7r29p1pf.xml" score="76" totalHits="2">
    <span class="MacroCode">...meta-data and snippets here...</span>
  &lt;/<b>docHit</b>>

  <span class="MacroCode">...additional document hits here...</span>
&lt;/<b>crossQueryResult</b>></pre>
    <p>Essentially, each matching document will have a corresponding<span class="Code"> 
      &lt;docHit&gt; </span>tag, and these will be sorted in some order, generally 
      by descending score (relevance). Each document hit contains corresponding 
      meta-data within a<span class="Code"> &lt;meta&gt; </span>sub-tag. Hits 
      on the full text of the document will have<span class="Code"> &lt;snippet&gt; 
      </span>tags, each with its own<span class="Code"> &lt;hit&gt; </span>tag 
      inside it.</p>
    <p>A little more formally, the result formatter receives a<span class="Code"> 
      &lt;crossQueryResult&gt; </span>tag that looks like this: </p>
    <pre class="Sample"><b>&lt;crossQueryResult queryTime = "<span class="MacroCode">TimeInSeconds</span>" 
                  totalDocs = "<span class="MacroCode">NumberOfDocs</span>" 
                  startDoc  = "<span class="MacroCode">FirstDocNumber</span>" 
                  endDoc    = "<span class="MacroCode">LastDocNumber</span>"&gt;
    <span class="MacroCode">Parameters
</span>    <span class="MacroCode">Query
</span>
    <span class="MacroCode">DocumentHit</span>
    <span class="MacroCode">DocumentHit</span>
        …
&lt;/crossQueryResult&gt;</b></pre>
    <p>Note that, depending on the query and the size of the document repository, 
      there might be thousands of matching documents, and this thousands of<span class="Code"> 
      &lt;docHit&gt; </span>tags. Suppose you only wanted to display the first 
      page of hits, say ten of them? It would be simple to make a <b>Result Formatter</b> 
      that simply picked the first 10 and ignored the rest, but that would be 
      very inefficient because the XSLT processor will still have to parse and 
      process <i>all</i> of the document hits. A much more efficient way to handle 
      paging is to modify the <b>Query Parser</b> to specify<span class="Code"> 
      maxDocs=&quot;10&quot; </span>in the<span class="Code"> &lt;query&gt; </span>element; 
      then only the first ten document hits will be passed to the <b>Result Formatter</b> 
      and the user interface will be much more responsive.</p>
    <p>Each Document Hit looks like this: </p>
    <pre class="Sample"><b>&lt;docHit rank="<span class="MacroCode">DocRelevanceRank</span>" path="<span class="MacroCode">DocumentLocation</span>" score="<span class="MacroCode">DocRelevanceScore</span>"&gt;
  &lt;meta&gt;
    <span class="MacroCode">Meta-data defined by index Pre-Filter stylesheet</span>
  &lt;/meta&gt;

  <span class="MacroCode">Snippet</span>
  <span class="MacroCode">Snippet</span>
    …
&lt;/docHit&gt;</b></pre>
    <p>The meta-data is copied directly from the tags in the input document marked 
      by the index Pre-Filter stylesheet using the<span class="Code"> xtf:meta=&quot;yes&quot; 
      </span>attribute. If the query targets meta-data fields, these may have<span class="Code"> 
      &lt;snippet&gt; </span>and/or<span class="Code"> &lt;hit&gt; </span>tags 
      embedded within them, marking the exact location of the matching terms. 
    </p>
    <p>If the query targets the &quot;text&quot; field -- that is, the full document 
      text -- then the<span class="Code"> &lt;docHit&gt; </span>tag will have 
      one or more<span class="Code"> &lt;snippet&gt; </span>tags containing the 
      matching text and some surrounding context:</p>
    <pre class="Sample"><b>&lt;snippet rank="<span class="MacroCode">MatchRelevanceRank</span>" score="<span class="MacroCode">MatchRelevanceScore</span>"&gt;

    <span class="MacroCode">Hit Text (and context text, if any)</span>

&lt;/snippet&gt;</b></pre>
    <p>Within each snippet will appear a<span class="Code"> &lt;hit&gt; </span>tag 
      with one or more<span class="Code"> &lt;term&gt; </span>tags marking the 
      exact matching terms.</p>
    <p>The bulk of the Result Formatter's work will be in transforming all these<span class="Code"> 
      &lt;docHit&gt;</span>,<span class="Code"> &lt;meta&gt;</span>,<span class="Code"> 
      &lt;snippet&gt;</span>, <span class="Code"> &lt;hit&gt;</span>, and<span class="Code"> 
      &lt;term&gt; </span>XML tags into meaningful HTML output. Writing XSLT is 
      beyond the scope of this document, but a good way to learn is to begin modifying 
      the sample <b>Result Formatter</b> stylesheet. The stylesheet is included 
      with the XTF distribution in the<span class="Code"> style/crossQuery/resultFormatter 
      </span>directory. </p>
    <p>It should also be noted that the various input tags have bells and whistles 
      not mentioned in this short tutorial. For a full specification, please refer 
      to the <a href="tagRef.html#crossQuery_ResultFormatter_Tags">Result 
      Formatter Tag Reference</a>.<br/>
    </p>
    
  <p class="Heading2">Other Common Tasks<a name="crossQuery_Common_Prog"></a></p>
    <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --> 
    
  <p>A fully fleshed-out <b><i>crossQuery</i></b> system will need to handle errors 
    gracefully. You may also wish to add session state features (to record data 
    that persists across page views.) Since these tasks are common to both servlets, 
    they are documented in the <a href="#Common_Prog">Common <i><b>crossQuery/dynaXML</b></i> 
    Programming Tasks</a> section below. </p>
  <p><!-- crossQuery --> </p>
</div>
  <hr/>
  <p class="Heading1">dynaXML Programming<a name="dynaXML_Prog"></a></p>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --> 
  <p>The <b><i>dynaXML</i></b> servlet is in charge of displaying a single XML 
    document, often in small chunks or pages, one page at a time. It forms part 
    of a complete search and display system: the user can search a collection 
    of documents using <b><i>crossQuery</i></b>, and when they find a document 
    of interest, they can explore the contents of that document using <b><i>dynaXML</i></b>. 
    If we look more closely at the dynaXML portion of the <a href="#SummaryDiagram">XTF 
    Overview Diagram</a>, we see something like this: <br/>
  </p>
  <p align="center"> <img src="art/dynaXMLDataFlow.gif" alt="dynaXML Data Flow"/><br/>
    Figure 7: Data Flow in the <b><i>dynaXML </i></b> Servlet </p>
  <p>Data flow in this diagram is from left to right. First, the user specifies 
    a document to view by sending a URL that looks like this (in its simplest 
    form):<br/>
  </p>
  <div class="Sample"> <span class="Code"> http://<span class="MacroCode">yourserver</span>:8080/xtf/view?docId=<span class="MacroCode">DocumentToView</span> 
    </span> </div>
  <p>The <i><b>dynaXML </b></i>servlet breaks up the URL parameters and formats 
    them in XML. This is passed to the <b>Document Request Parser</b> stylesheet, 
    which figures out where to find the specified document and decides which stylesheet 
    will be used for formatting the result page. Also, if a search query is included 
    in the URL, the parser transforms the query into structured XML that the <b>Text 
    Engine </b>can understand.</p>
  <p>Optionally, the parser can also specify authentication to perform, allowing 
    the system to secure access to sensitive or protected documents. XTF's user 
    authentication engine checks the user's credentials using the specified authentication 
    method. </p>
  <p>Next, the servlet fetches the source XML document. If a search query was 
    specified, it uses the <b>Text Engine</b> to search for occurrences of the 
    specified text, and then inserts hit tags and snippets in their proper context 
    within the original document. </p>
  <p>Finally, the (possibly marked up) document is passed to the <b>Document Formatter</b> 
    stylesheet, which creates the final HTML page to display in the user's browser.</p>
  <p>Thus, XTF allows you to configure, again through the use of stylesheets, 
    where documents will be stored, how they can be queried, and precisely how 
    they will be displayed to the user. How are all these decisions made? This 
    diagram should clarify the chain of logic:</p>
  <p align="center"> <img src="art/dynaXMLDecisionTree.gif" alt="dynaXML Decision Tree"/><br/>
    Figure 8: Decision Tree of the <b><i>dynaXML </i></b> Servlet </p>
<p>The following sections cover the basics of programming stylesheets to drive 
    <i><b>dynaXML</b></i>.</p>
  <div class="IndentL"> 
    <p class="Heading2">Document Request Parser Programming<a name="dynaXML_DocReqParser_Prog"></a></p>
    <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --> 
    <p>As discussed above, the <b>Document Request Parser</b> is responsible for 
      interpreting a URL based query. XTF allows great flexibility in terms of 
      how URLs are constructed and interpreted, and this stylesheet is the key 
      to that flexibility.</p>
    <p>The main tasks of the Document Request Parser are:</p>
    <ol>
      <li>Use the URL parameters to determine which document to display, and figure 
        out exactly where to find it. Typically it will come up with a full path 
        to an XML file in the filesystem, but it can also come from an external 
        HTTP source.<br/>
        <br/>
      </li>
      <li>Decide which <b>Document Formatter</b> stylesheet to use. Many systems 
        will have only one Document Formatter, but one can set up a more complex 
        system where different formatters are used for different types of documents, 
        or are switched by a URL parameter.<br/>
        <br/>
      </li>
      <li>Specify what authentication is required to view the document, if any. 
        This can be IP-based filtering, looking up a username/password in an LDAP 
        database, or using an external login web page.<br/>
        <br/>
      </li>
      <li>If a text query is specified, the <b>Document Request Parser </b>is 
        responsible for structuring that query in the same fashion as crossQuery's 
        <b>Query Request Parser</b>. In fact, it often makes sense for one parser 
        to call the other, or for them to share a common stylesheet that handles 
        parsing duties. </li>
    </ol>
    <p>Suppose a user, through <i><b>crossQuery</b></i>, searches for the word 
      &quot;apartheid&quot;. The top document hit will be the book <u>The Opening 
      of the Apartheid Mind</u> (assuming you've indexed the sample data available 
      with the XTF distribution.) If the user clicks on that title, <i> <b>dynaXML</b></i> 
      is then invoked with a URL like this: </p>
      
    <pre class="Sample"><b> http://<span class="MacroCode">yourserver</span>:8080/xtf/view?docId=mm/ft958009mm/ft958009mm.xml&amp;query=apartheid</b></pre>
    Notice that the first part of the URL (everything before the <b>?</b> symbol) 
    invokes the <b><i>dynaXML</i></b> servlet, and second part of the URL (everything 
    after the <b>?</b> symbol) defines which document to display and a text query 
    to run on it. <br/>
    <br/>
    <table width="90%" cellpadding="0" cellspacing="12">
      <tr> 
        <td width="213" align="right" valign="baseline" class="Code">docId=mm/ft958009mm/ft958009mm.xml</td>
        <td width="246" valign="baseline"><span class="BaseStyle">The identifier 
          of the document to view.</span></td>
      </tr>
      <tr> 
        <td width="213" align="right" valign="baseline" class="Code">query=apartheid</td>
        <td width="246" valign="baseline"><span class="BaseStyle">The word to 
          search for in the document.</span></td>
      </tr>
    </table>
    <p> The <i><b>dynaXML</b></i> servlet transforms the URL parameters into an 
      XML document, suitable for processing by the <b>Document Request Parser</b> 
      (which is of course written in XSLT.) The parser included with the XTF distribution 
      is called<span class="Code"> docReqParser.xsl</span>, and we'll discuss 
      what it does below.</p>
    <p>The input document will always have the form: </p>
    <pre class="Sample"><b>&lt;parameters&gt;

  &lt;param name="<span class="MacroCode">ParamName</span>" value="<span class="MacroCode">ParamValue</span>"&gt;
      <span class="MacroCode">Token</span> | <span class="MacroCode">Phrase</span>
      <span class="MacroCode">Token</span> | <span class="MacroCode">Phrase</span>
           …
  &lt;/param&gt;
      …
&lt;/parameters&gt;</b></pre>
    where <span class="MacroCode">Token</span> specifies a single word, and has 
    the form: <br/>
    <br/>
    <div class="Sample"> <span class="Code"> &lt;token value="<span class="MacroCode">Word</span>" 
      isWord = "<span class="MacroCode">YesOrNo</span>"/&gt; </span> <br/>
      <br/>
      where <br/>
      <br/>
      <table cellpadding="0" cellspacing="12">
        <tr> 
          <td width="16%" align="right" valign="top" class="Code"> value="<span class="MacroCode">Word</span>" 
          </td>
          <td><span class="BaseStyle">is the actual word or symbol extracted from 
            the URL.</span></td>
        </tr>
        <tr> 
          <td width="16%" align="right" valign="top" class="Code"> isWord="<span class="MacroCode">YesOrNo</span>" 
          </td>
          <td><span class="BaseStyle">identifies whether the token is a word or 
            punctuation symbol.</span></td>
        </tr>
      </table>
    </div>
    <br/>
    and <span class="MacroCode">Phrase</span> specifies an entire phrase extracted 
    as a single string, with the form: <br/>
    <br/>
    <div class="Sample"> 
      <pre class="Code">&lt;phrase value="<span class="MacroCode">StringOfWords</span>"&gt;
    <span class="MacroCode">Token</span>
      …
    <span class="MacroCode">Token</span>
&lt;/phrase&gt;
</pre>
      where <br/>
      <br/>
      <table cellpadding="0" cellspacing="12">
        <tr> 
          <td width="16%" align="right" valign="top" class="Code"> value="<span class="MacroCode">StringOfWords</span>" 
          </td>
          <td><span class="BaseStyle">is the entire phrase extracted from the 
            URL as a single string.</span></td>
        </tr>
        <tr> 
          <td width="16%" align="right" valign="top" class="Code"> <span class="MacroCode">Token</span>...<span class="MacroCode">Token</span> 
          </td>
          <td> <span class="BaseStyle"> is the original phrase broken down into 
            individual token tags for each word or symbol in the phrase. </span> 
          </td>
        </tr>
      </table>
    </div>
    <p><br/>
      For the sample URL above, the XML passed to the <b>Document Request Parser</b> 
      looks like this: <br/>
    </p>
    <pre class="Sample"><b>&lt;parameters&gt;

  &lt;param name="docId" value="mm/ft958009mm/ft958009mm.xml"&gt;
     &lt;token value="mm/ft958009mm/ft958009mm.xml" isWord="yes"/&gt;
  &lt;/param&gt;

  &lt;param name="query" value="apartheid"&gt;
     &lt;token value="apartheid" isWord="yes"/&gt;
  &lt;/param&gt;

&lt;/parameters&gt;</b></pre>
    <p>Our example doesn't have a phrase in it or a multi-word parameter, but 
      if you're curious how those would look, see the example in the section on 
      <a href="#crossQuery_QueryParser_Prog">Query Parser Programming</a> above.</p>
    <p>The sample<span class="Code"> docReqParser.xsl </span>creates the following 
      output based on the input<span class="Code"> &lt;parameters&gt; </span>block.</p>
    <pre class="Sample"><b>&lt;style path="style/dynaXML/docFormatter/default/docFormatter.xsl"/>
&lt;source path="data/mm/ft958009mm/ft958009mm.xml"/>
&lt;index configPath="conf/textIndexer.conf" name="default"/>
&lt;query indexPath="index" termLimit="1000" workLimit="500000">
   &lt;and field="text" maxSnippets="-1" maxContext="80">
      &lt;term>apartheid&lt;/term>
   &lt;/and>
&lt;/query>
&lt;auth access="allow" type="all"/></b></pre>
    <p>Let's analyze this in small pieces.</p>
    <pre class="Sample"><b>&lt;style path="style/dynaXML/docFormatter/default/docFormatter.xsl"/></b></pre>
    <p>The<span class="Code"> &lt;style&gt; </span>tag directs dynaXML to the 
      <b>Document Formatter</b> stylesheet to use for this request. The path is 
      relative to the XTF base directory.</p>
    <pre class="Sample"><b>&lt;source path="data/mm/ft958009mm/ft958009mm.xml"/></b></pre>
    <p>Next, the<span class="Code"> &lt;source&gt; </span>tag identifies the location 
      of the source document that should be displayed. Again the path is relative 
      to the XTF base directory. The sample data is laid out in subdirectories 
      based on deconstructing the document ID, but one could write a parser that 
      used some other strategy for locating documents.</p>
    <pre class="Sample"><b>&lt;index configPath="conf/textIndexer.conf" name="default"/></b></pre>
    <p>For speed, dynaXML includes a facility called &quot;Lazy Trees&quot; which 
      creates a binary representation of the input document on disk. The binary 
      version is much faster to process, especially if the input document is large 
      but the parts of it needed by the <b>Document Formatter</b> are small. In 
      any case, <i><b>dynaXML</b></i> needs to know where to find the Lazy Trees 
      created by the <b><i>textIndexer</i></b>, or where to create them if not 
      found. The<span class="Code"> &lt;index&gt; </span>tag tells it where to 
      find the index configuration file, and the name of the index subset. If 
      you're interested in learning more about Lazy Trees, see <a href="underHood.html#LazyFiles">XTF 
      Under the Hood</a>.</p>
    <pre class="Sample"><b>&lt;query indexPath="index" termLimit="1000" workLimit="500000">
   &lt;and field="text" maxSnippets="all" maxContext="80">
      &lt;term>apartheid&lt;/term>
   &lt;/and>
&lt;/query></b></pre>
    <p>Next comes a query to run against the full text of the document. Of course 
      the query is optional, but if included, its format is exactly the same as 
      the output of <i><b>crossQuery</b></i>'s <b>Query Parser</b>. In fact, the 
      default<span class="Code"> docReqParser.xsl </span>simply uses<span class="Code"> 
      &lt;xsl:import&gt; </span>to incorporate <span class="Code">queryParser.xsl</span>, 
      and uses its templates to do the work of parsing and formatting the text 
      query.</p>
    <p>One curious thing to see here is <span class="Code">maxSnippets=&quot;all&quot;</span>. 
      In this case,<span class="Code"> all </span>is a special value, telling 
      the <b>Text Engine</b> to gather <i>all</i> of the snippets/hits for the 
      given document. If you only wanted the ten best scoring hits, you could 
      specify <span class="Code">maxSnippets=&quot;10&quot; </span>instead.</p>
    <pre class="Sample"><b>&lt;auth access="allow" type="all"/></b></pre>
    <p>The final tag produced by the <b>Document Request Parser</b> is the<span class="Code"> 
      &lt;auth&gt; </span>tag, which specifies authentication to perform. The 
      simplest tag is shown above, and simply allows access to all users. Other 
      authentication mechanisms are available; for more information please consult 
      the section on <a href="deployment.html#UserAuthentication">User 
      Authentication</a> in the XTF Deployment Guide. Multiple<span class="Code"> 
      &lt;auth&gt; </span>tags will be processed in order until one succeeds or 
      fails.</p>
    <p>Customizing the <b>Document Request Parser</b> is beyond the scope of this 
      document, but a good place to start is by incrementally modifying the sample<span class="Code"> 
      docReqParser.xsl </span>included with the XTF distribution.<br/>
    </p>
    <p class="Heading2">Document Formatter Programming<a name="dynaXML_DocFormatter_Prog"></a></p>
    <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --> 
    The <b>Document Formatter</b> stylesheet receives as its input the requested 
    XML document. For its output it should produce an HTML based document web-page 
    that can be viewed in the user's browser. <br/>
    <br/>
    The XML document passed by the <i><b>dynaXML</b></i> servlet to the Document 
    Formatter stylesheet consists of the original XML source document with the 
    following additions: <br/>
    <ul>
      <li class="ListItem"> Any added <a href="tagRef.html#textIndexer_Tag_Ref">attributes</a> 
        introduced by the <b><i>textIndexer</i></b> <b>Pre-Filter</b> when the 
        document was indexed. <br/>
        <br/>
      </li>
      <li class="ListItem"> If a query accompanied the document request, a<span class="Code"> 
        snippets </span>tag will appear at the top of the document, summarizing 
        of all the hits found within the document, including a configurable amount 
        of surrounding text.<br/>
        <br/>
      </li>
      <li class="ListItem"> If a query accompanied the document request, then 
        zero or more<span class="Code"> <a href="tagRef.html#dynaXML_DocFormatter_Hit">hit</a> 
        </span>and<span class="Code"> <a href="tagRef.html#dynaXML_DocFormatter_Term">term</a> 
        </span>tags will appear around matching text in the main body of the document 
        for the given query. If a hit spans the boundary between one XML element 
        and the next, the<span class="Code"> hit </span>tag will end and a<span class="Code"> 
        <a href="tagRef.html#dynaXML_DocFormatter_More">more</a> 
        </span>tag will resume inside the next element.</li>
    </ul>
    <p> The<span class="Code"> snippets </span> summary tag will have the following 
      form: </p>
    <pre class="Sample"><span class="Code">&lt;xtf:snippets&gt;
  <span class="MacroCode">Snippet</span>
  <span class="MacroCode">Snippet</span>
    …
&lt;/xtf:snippets&gt;</span></pre>
    <p>where each <span class="MacroCode">Snippet</span> is a <b><i>dynaXML</i></b><span class="Code"> 
      <a href="tagRef.html#dynaXML_DocFormatter_Snippet">snippet</a> 
      </span>tag that summarizes one query match in the requested document. </p>
    <p>The additional tags and attributes added by the <b><i>textIndexer</i></b> 
      and the <b><i>dynaXML</i></b> servlet are prefixed with an<span class="Code"> 
      xtf: </span>namespace to clearly differentiate them from other tags in the 
      XML document.</p>
    <p>It should be noted that, unlike the <b>Result Formatter</b> in <i><b>crossQuery</b></i>, 
      the <b>Document Formatter</b> does not receive the<span class="Code"> &lt;parameters&gt; 
      </span>block from the URL request. But if it needs access to the URL parameters, 
      they are always available through global<span class="Code"> &lt;xsl:param&gt; 
      </span>declarations.</p>
    <p>Sometimes it is helpful to view the raw XML that <i><b>dynaXML</b></i> 
      passes to the <b>Document Formatter</b>. To do this, add <span class="Code"> 
      &amp;raw=1 </span>to the URL, and the servlet will bypass the formatter 
      completely and display the raw XML directly in your browser. Beware however 
      that large documents may take quite some time to process and transmit.</p>
    <p></p>
    <p>Writing the <b>Document Formatter</b> can be quite challenging, as many 
      options are possible and the output is very dependent on the structure of 
      the input XML document. In addition, if your collection includes several 
      types of documents, you may need several formatters. Writing XSLT is beyond 
      the scope of this tutorial, but you may get some ideas by examining the 
      sample<span class="Code"> docFormatter.xsl </span>included with the XTF 
      distribution.</p>
    <p>As with everything in XTF, it is advisable (and fun) to start with something 
      simple and then progressively refine the stylesheets over time.</p>
    
  <p class="Heading2">Other Common Tasks<a name="dynaXML_Common_Prog"></a></p>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --> 
  <p>A fully fleshed-out <b><i>dynaXML</i></b> system will need to handle errors 
    gracefully. You may also wish to add session state features (to record data 
    that persists across page views.) Since these tasks are common to both servlets, 
    they are documented in the <a href="#Common_Prog">Common <i><b>crossQuery/dynaXML</b></i> 
    Programming Tasks</a> section below.<br/>
  </p>
  </div>
  <hr/>
<p class="Heading1">Common <i>crossQuery/dynaXML</i> Programming Tasks<a name="Common_Prog"></a></p>
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --> 
  
<p>The <b><i>dynaXML</i></b> and <b><i>crossQuery </i></b>servlets share some 
  aspects of their operation. Instead of repeating the documentation for these 
  common parts in each section, these common tasks are collected below.</p>
<div class="IndentL"> 
    <p class="Heading2">Error Generator Programming for <i><b>crossQuery</b></i> 
      and<i><b> dynaXML</b></i><a name="Common_ErrorGen_Prog"></a></p>
<!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --> 
  <p>It's not a perfect world, and errors happen. For the times when they do, 
    the <i><b>crossQuery</b></i> and <b><i>dynaXML </i></b>servlets include a 
    handy stylesheet-based mechanism to put a nice face on things, creating a 
    formatted HTML page letting the user know what happened, and potentially how 
    to fix it. This stylesheet is called the <b>Error Generator</b>.</p>
<p>Here are the main sources of errors that activate the servlet's error handling 
  mechanism:</p>
  <ol>
    <li>Configuration errors, such as invalid parameters in the<span class="Code"> 
      crossQuery.conf </span>or<span class="Code"> dynaXML.conf </span>file, or 
      missing stylesheets.</li>
    <li>Errors detected by the<b> Query Parser </b>stylesheet. It lets the servlet 
      know something went wrong by outputting an<span class="Code"> &lt;error&gt; 
      </span>tag instead of the normal<span class="Code"> &lt;query&gt; </span>tag.</li>
    <li>Incorrect syntax in the<span class="Code"> &lt;query&gt; </span>tag produced 
      by the <b>Query Parser</b>.</li>
    <li>Incorrect syntax in the tags produced by the <b>Document Request Parser</b>.</li>
    <li>Problems that occur while the<b> Text Engine </b>is reading the input 
      document or executing a query. Some such errors include trying to query 
      a document that hasn't been indexed, or attempting a wildcard query on too 
      many terms.</li>
    <li>Bugs in the XTF system itself (hopefully very rare.)</li>
  </ol>
  <p>In all these cases, the servlet looks in the<span class="Code"> crossQuery.conf 
    </span>or<span class="Code"> dynaXML.conf </span>file for the<span class="Code"> 
    &lt;errorGen&gt; </span>tag that specifies an <b>Error Generator </b>stylesheet 
    to run. The servlet constructs a small input document with details about the 
    particular error and passes it to the <b>Error Generator</b>, whose job is 
    to output a nice-looking error page.</p>
<p>The following query will create an error with the sample distribution (it performs 
  a wildcard query on all terms): </p>
<div class="Sample"> <span class="Code"> http://<span class="MacroCode">yourserver</span>:8080/xtf/search?text=* 
  </span> </div>
<p>This exceeds the default limit on the number of terms a query can access, so 
  <i><b>crossQuery </b></i>calls the <b>Error Generator</b> with the following 
  input:</p>
<pre class="Sample"><b>&lt;TermLimit>
   &lt;message>
     Wildcard query on 'text' matched too many terms (more than 1000). 
     First 50 matches: $ + 0 0.0 0.00 0.0001 0.001 0.0015 0.0029 0.003 
     0.0034 0.004 0.005 0.006 0.007 0.008 0.009 0.01 0.010 0.011 0.012 
     <span class="MacroCode">...more terms here...
</span>   &lt;/message&gt;
&lt;/TermLimit></b></pre>
<p>Writing the XSLT code that transforms the various error tags is beyond the 
  scope of this document, but the default <b>Error Generator</b> included with 
  the XTF distribution is a good place to start. It can be found in the<span class="Code"> 
  style/crossQuery </span>directory. </p>
  <p>An easy way to check the input to your <b>Error Generator</b> is to add<span class="Code"> 
    &amp;raw=1 </span>to your query URL. When an error occurs, the servlet will 
    dump the raw XML to the browser, instead of sending it to the stylesheet.</p>
  <p>Each kind of error specifies different information for the <b>Error Generator</b> 
    to work on. For instance, authentication failures include the requestor's 
    IP address, whereas internal errors include a Java stack trace. For a full 
    list of the various errors that may be sent by <i><b>crossQuery </b></i>to 
    the <b> Error Generator</b>, please consult the <a href="tagRef.html#Error_Generators">Error 
    Generator Stylesheet Reference</a>.</p>

  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --> 
  <p class="Heading2">Tracking Session State<a name="Common_Session_State"></a></p>
    <p>By default, <i><b>crossQuery </b></i>and <i><b>dynaXML </b></i>are &quot;stateless&quot;, 
      that is, they don't remember anything from one request to the next. Any 
      given URL request is treated separately, and all the servlet knows is what 
      is present in the URL parameters.</p>
    <p>URL parameters are fine for small pieces of data that change frequently, 
      such as query parameters, page number, document ID, etc. However they're 
      cumbersome for large amounts of data, or information that doesn't change 
      frequently. This is where <i><b>XTF</b></i>'s <b>Session State Tracking</b> 
      facilities come in handy.</p>
    <p>Once session tracking enabled, XTF will associate a session ID with the 
      first request made by a particular user. As the user clicks on links from 
      that page, the session ID will automatically track along with each page 
      view. Your parsing and formatting stylesheets can store and retrieve data 
      in the session, and this data will be available on subsequent requests.</p>
    <p>A brief tutorial on session tracking follows; details of the functions 
      are detailed in the <a href="tagRef.html#Session_State">Session 
      State</a> section of the XTF Stylesheet Reference.<br/>
    </p>
    <div class="IndentLR"> 
      <p class="Heading3">Enabling Session Tracking</p>
      <p> <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --> 
        Before attempting to store or retrieve session data, you must enable session 
        tracking in the configuration file of the servlet(s) you're using (i.e.<span class="Code"> 
        dynaXML.conf </span>and/or<span class="Code"> crossQuery.conf</span>). 
        The line to enable tracking looks like this:</p>
      <div class="Sample"> <span class="Code"> </span> <span class="Code">&lt;<b>trackSessions 
        track=&quot;yes&quot;</b>/&gt; </span></div>
      <p class="Heading3">Storing and Retrieving Session Data</p>
      <p> <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --> 
        Once enabled, XTF's built-in XSL extension functions can be used to store 
        or retrieve data in the session associated with a given request. For example, 
        here's some XSL code to store a value in the session:</p>
      <pre class="Sample"><b>&lt;xsl:stylesheet <span class="Red">xmlns:session="java:org.cdlib.xtf.xslt.Session</span>"<span class="MacroCode">...</span>&gt;<span class="MacroCode">
...</span>
  &lt;xsl:value-of select="<span class="Red">session:setData</span>('<span class="MacroCode">someName</span>', '<span class="MacroCode">someValue</span>')"></b></pre>
      <p>As you see, the<span class="Code"> session:setData </span>function can 
        be used like any other XPath function, as long as the proper namespace 
        has been declared. It places data into the session under the given name 
        (replacing any previous data with that name.)</p>
      <p>In general the session data can contain as many name/value pairs as you 
        wish to place into it. The the value can be either a string or structured 
        XML; if you use XML that contains more than one element, be sure to include 
        a single outer wrapper element as in the following example:</p>
      <pre class="Sample"><b>&lt;xsl:variable name=&quot;newValue&quot;&gt;
  <span class="Red">&lt;myWrapper&gt;</span>
    &lt;element1&gt;<span class="MacroCode">...</span>&lt;/element1&gt;
    &lt;element2&gt;<span class="MacroCode">...</span>&lt;/element2&gt;
    <span class="MacroCode">...</span>
  <span class="Red">&lt;/myWrapper&gt;</span>
&lt;/xsl:variable&gt;

&lt;xsl:value-of select="session:setData('<span class="MacroCode">someName</span>', $newValue)"></b></pre>
      <p></p>
      <p>Retrieving session data is also very simple:</p>
      <pre class="Sample"><b>&lt;xsl:variable name=&quot;myData&quot; select=&quot;<span class="Red">session:getData</span>('<span class="MacroCode">someName</span>')"></b></pre>
      <p></p>
      <p>The<span class="Code"> session:getData </span>function retrieves the 
        data value established for this name by<span class="Code"> session:setData</span>. 
        If no data was previously stored under that name, null is returned. (i.e. 
        empty string/empty sequence). </p>
      <p class="Heading3">The Session ID and How it is Tracked</p>
      <p> <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --> 
        XTF automatically creates and tracks session identifiers for you. In general 
        you don't have to do any additional work for this to happen transparently 
        in the background. However, one case may require more work.</p>
      <p>By default, when session tracking is enabled, XTF attempts to set a cookie 
        in the user's browser. This cookie simply contains the session ID, and 
        is timed to expire at the end of the user's browsing session. On subsequent 
        requests, the browser will automatically return the cookie to XTF, providing 
        the session ID.</p>
      <p>However, some users disable cookies due to privacy concerns. If XTF detects 
        that the cookie was not accepted, it automatically switches to using the 
        URL to store the session identifier. Typically you'll see &quot;<span class="Code">;jsessionid=<span class="MacroCode">xxxxx</span></span>&quot; 
        added to the URL in this case, just before the '<span class="Code">?</span>' 
        that begins the normal URL parameters.</p>
      <p class="Heading3">URL Encoding of the Session ID</p>
      <p> <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --> 
        When URL encoding is activated, XTF automatically intercepts URLs that 
        your stylesheets produce as part of<span class="Code"> &lt;form&gt;</span>,<span class="Code"> 
        &lt;a&gt;</span>, and<span class="Code"> &lt;frame&gt; </span>elements 
        in the output HTML. XTF will then add the session ID to the URLs as appropriate. 
      </p>
      <p>Though not common, if your HTML output contains URLs as part of other 
        elements or in JavaScript calls, then you'll need to inform XTF that these 
        URLs may need to have the session ID added. This is done using the<span class="Code"> 
        session:encodeURL </span>function like this:</p>
      <pre class="Sample"><b>&lt;xsl:variable name=&quot;originalURL&quot; select=&quot;<span class="MacroCode">some value here</span>&quot;/&gt;
&lt;xsl:variable name=&quot;encodedURL&quot; select=&quot;<span class="Red">session:encodeURL</span>($originalURL)&quot;/&gt;</b> </pre>
      <p>XTF will check the URL and if it points to an XTF servlet and the session 
        ID needs to be tracked in the URL, it will return a modified version of 
        the URL that contains the session ID.</p>
      <p class="Heading3">Getting the session ID</p>
      <p> <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --> 
        You may want to record the identifier of the current session for reference 
        in a database. To obtain the identifier, use code like this:</p>
      <pre class="Sample"><b>&lt;xsl:variable name=&quot;sessionID&quot; select=&quot;<span class="Red">session:getID()</span>&quot;/&gt;</b> </pre>
      <p class="Heading3">Checking Whether Session Tracking is Enabled</p>
      <p> <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --> 
        If you wish, you can create stylesheet code that works differently depending 
        on whether session tracking is enabled in the configuration file for the 
        particular servlet you're working in. It looks like this:</p>
      <pre class="Sample"><b>&lt;xsl:if test=&quot;<span class="Red">session:isEnabled()</span>&quot;&gt;
  &lt;!-- Do session-related stuff here --&gt;
&lt;/xsl:if&gt;</b> </pre>
      <p></p>
      <p>&nbsp;</p>
    </div>
  </div>

  <!-- Common --> 
  <!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --><br/>
</div>
</body>


</html>
